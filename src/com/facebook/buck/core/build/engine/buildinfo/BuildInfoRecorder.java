/*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.facebook.buck.core.build.engine.buildinfo;

import com.facebook.buck.core.model.BuildId;
import com.facebook.buck.core.model.BuildTarget;
import com.facebook.buck.io.filesystem.ProjectFilesystem;
import com.facebook.buck.util.hashing.FileHashLoader;
import com.facebook.buck.util.json.ObjectMappers;
import com.facebook.buck.util.timing.Clock;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Joiner;
import com.google.common.base.Preconditions;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Ordering;
import com.google.common.collect.Sets;
import com.google.common.hash.HashCode;
import com.google.common.hash.Hasher;
import com.google.common.hash.Hashing;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import javax.annotation.Nullable;

/**
 * Utility for recording the paths to the output files generated by a build rule, as well as any
 * metadata about those output files. This data will be packaged up into an artifact that will be
 * stored in the cache. The metadata will also be written to disk so it can be read on a subsequent
 * build by an {@link OnDiskBuildInfo}.
 */
public class BuildInfoRecorder {

  @VisibleForTesting
  static final String ABSOLUTE_PATH_ERROR_FORMAT =
      "Error! '%s' is trying to record artifacts with absolute path: '%s'.";

  private static final String BUCK_CACHE_DATA_ENV_VAR = "BUCK_CACHE_DATA";

  private final BuildTarget buildTarget;
  private final Path pathToMetadataDirectory;
  private final ProjectFilesystem projectFilesystem;
  private final BuildInfoStore buildInfoStore;
  private final Clock clock;
  private final BuildId buildId;
  private final ImmutableMap<String, String> artifactExtraData;
  private final Map<String, String> metadataToWrite;
  private final Map<String, String> buildMetadata;

  /** Every value in this set is a path relative to the project root. */
  private final Set<Path> pathsToOutputs;

  public BuildInfoRecorder(
      BuildTarget buildTarget,
      ProjectFilesystem projectFilesystem,
      BuildInfoStore buildInfoStore,
      Clock clock,
      BuildId buildId,
      ImmutableMap<String, String> environment) {
    this.buildTarget = buildTarget;
    this.pathToMetadataDirectory =
        BuildInfo.getPathToArtifactMetadataDirectory(buildTarget, projectFilesystem);
    this.projectFilesystem = projectFilesystem;
    this.buildInfoStore = buildInfoStore;
    this.clock = clock;
    this.buildId = buildId;

    this.artifactExtraData =
        ImmutableMap.<String, String>builder()
            .put(
                "artifact_data",
                Optional.ofNullable(environment.get(BUCK_CACHE_DATA_ENV_VAR)).orElse("null"))
            .build();

    this.metadataToWrite = new LinkedHashMap<>();
    this.buildMetadata = new LinkedHashMap<>();
    this.pathsToOutputs = new HashSet<>();
  }

  private String toJson(Object value) {
    try {
      return ObjectMappers.WRITER.writeValueAsString(value);
    } catch (IOException e) {
      throw new RuntimeException(e);
    }
  }

  private static String formatAdditionalArtifactInfo(Map<String, String> entries) {
    StringBuilder builder = new StringBuilder();
    for (Map.Entry<String, String> entry : entries.entrySet()) {
      builder.append(entry.getKey());
      builder.append('=');
      builder.append(entry.getValue());
      builder.append(',');
    }
    return builder.toString();
  }

  private ImmutableMap<String, String> getBuildMetadata() {
    return ImmutableMap.<String, String>builder()
        .put(
            BuildInfo.MetadataKey.ADDITIONAL_INFO,
            formatAdditionalArtifactInfo(
                ImmutableMap.<String, String>builder()
                    .put("build_id", buildId.toString())
                    .put(
                        "timestamp",
                        String.valueOf(TimeUnit.MILLISECONDS.toSeconds(clock.currentTimeMillis())))
                    .putAll(artifactExtraData)
                    .build()))
        .putAll(buildMetadata)
        .build();
  }

  /**
   * Writes the metadata currently stored in memory to the directory returned by {@link
   * BuildInfo#getPathToArtifactMetadataDirectory(BuildTarget, ProjectFilesystem)}.
   */
  public void writeMetadataToDisk(boolean clearExistingMetadata) throws IOException {
    if (clearExistingMetadata) {
      buildInfoStore.deleteMetadata(buildTarget);
      projectFilesystem.deleteRecursivelyIfExists(pathToMetadataDirectory);
    }
    projectFilesystem.mkdirs(pathToMetadataDirectory);

    ImmutableMap.Builder<String, String> artifactMetadata = ImmutableMap.builder();
    for (Map.Entry<String, String> entry : metadataToWrite.entrySet()) {
      if (!entry.getKey().equals(BuildInfo.MetadataKey.DEP_FILE)) {
        artifactMetadata.put(entry.getKey(), entry.getValue());
      } else {
        projectFilesystem.writeContentsToPath(
            entry.getValue(), pathToMetadataDirectory.resolve(entry.getKey()));
      }
    }

    projectFilesystem.writeContentsToPath(
        ObjectMappers.WRITER.writeValueAsString(artifactMetadata.build()),
        BuildInfo.getPathToArtifactMetadataFile(buildTarget, projectFilesystem));

    updateBuildMetadata();
  }

  public void updateBuildMetadata() throws IOException {
    buildInfoStore.updateMetadata(buildTarget, getBuildMetadata());
  }

  /**
   * Used by the build engine to record metadata describing the build (e.g. rule key, build UUID).
   */
  public BuildInfoRecorder addBuildMetadata(String key, String value) {
    buildMetadata.put(key, value);
    return this;
  }

  /**
   * This key/value pair is stored in memory until {@link #writeMetadataToDisk(boolean)} is invoked.
   */
  public void addMetadata(String key, String value) {
    metadataToWrite.put(key, value);
  }

  public void addMetadata(String key, ImmutableList<String> value) {
    addMetadata(key, toJson(value));
  }

  private ImmutableSortedSet<Path> getRecordedMetadataFiles() {
    return FluentIterable.from(metadataToWrite.keySet())
        .filter(key -> key.equals(BuildInfo.MetadataKey.DEP_FILE))
        .transform(Paths::get)
        .transform(pathToMetadataDirectory::resolve)
        .toSortedSet(Ordering.natural());
  }

  public ImmutableSortedSet<Path> getRecordedPaths() {
    return ImmutableSortedSet.<Path>naturalOrder()
        .addAll(getRecordedMetadataFiles())
        .addAll(pathsToOutputs)
        .build();
  }

  public HashCode getOutputHash(FileHashLoader fileHashLoader) throws IOException {
    Hasher hasher = Hashing.md5().newHasher();
    for (Path path : getRecordedPaths()) {
      hasher.putBytes(fileHashLoader.get(projectFilesystem.resolve(path)).asBytes());
    }
    return hasher.hash();
  }

  /** @param pathToArtifact Relative path to the project root. */
  public void recordArtifact(Path pathToArtifact) {
    Preconditions.checkArgument(
        !pathToArtifact.isAbsolute(), ABSOLUTE_PATH_ERROR_FORMAT, buildTarget, pathToArtifact);
    pathsToOutputs.add(pathToArtifact);
  }

  @Nullable
  @VisibleForTesting
  String getMetadataFor(String key) {
    return metadataToWrite.get(key);
  }

  public Optional<String> getBuildMetadataFor(String key) {
    return Optional.ofNullable(buildMetadata.get(key));
  }

  public void assertOnlyHasKeys(String... keys) {
    Sets.SetView<String> difference =
        Sets.difference(buildMetadata.keySet(), ImmutableSet.copyOf(keys));
    Preconditions.checkState(
        difference.isEmpty(), "Contained extra keys: " + Joiner.on(":").join(difference));
  }
}
