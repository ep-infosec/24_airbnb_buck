/*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.facebook.buck.core.rules.providers.impl;

import com.facebook.buck.core.rules.providers.Provider;
import com.facebook.buck.core.rules.providers.ProviderInfo;
import com.facebook.buck.core.rules.providers.annotations.ImmutableInfo;
import com.facebook.buck.core.starlark.compatible.BuckStarlarkFunction;
import com.facebook.buck.core.starlark.compatible.MethodLookup;
import com.facebook.buck.core.util.immutables.BuckStylePrehashedValue;
import com.facebook.buck.util.types.Either;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;
import com.google.devtools.build.lib.events.Location;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.Parameter;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import javax.annotation.Nullable;

/**
 * A {@link Provider} for a {@link ProviderInfo} that is declared in java. The provider is auto
 * generated by any {@link BuiltInProviderInfo} that is declared via reflection.
 *
 * @param <T> the specific type of the {@link ProviderInfo} this instance of the provider creates.
 */
public class BuiltInProvider<T extends BuiltInProviderInfo<T>> extends BuckStarlarkFunction
    implements Provider<T> {

  private static final String SKYLARK_CONSTRUCTOR_METHOD_NAME = "instantiateFromSkylark";

  protected final BuiltInKey<T> key;
  private final Either<Constructor<? extends T>, Method> infoFactory;

  private BuiltInProvider(
      Class<? extends T> infoClass,
      Constructor<? extends T> infoConstructor,
      List<String> infoApiFields,
      List<String> defaultSkylarkValues,
      Set<String> noneableParams) {
    super(
        infoClass.getSimpleName(),
        infoConstructor,
        infoApiFields,
        defaultSkylarkValues,
        noneableParams);
    this.key = ImmutableBuiltInKey.of(infoClass);
    infoConstructor.setAccessible(true);
    this.infoFactory = Either.ofLeft(infoConstructor);
  }

  private BuiltInProvider(
      Class<? extends T> infoClass,
      Method infoFactory,
      List<String> infoApiFields,
      List<String> defaultSkylarkValues,
      Set<String> noneableParams) {
    super(
        infoClass.getSimpleName(),
        infoFactory,
        infoApiFields,
        defaultSkylarkValues,
        noneableParams);
    this.key = ImmutableBuiltInKey.of(infoClass);
    infoFactory.setAccessible(true);
    this.infoFactory = Either.ofRight(infoFactory);
  }

  /**
   * @param infoClass the generated immutable class containing the API of the {@link ProviderInfo}
   *     we want to expose.
   * @param <U> the type of the specific {@link BuiltInProviderInfo} this provider is for.
   * @return a {@link BuiltInProvider} that identifies and can be used to construct the {@link
   *     BuiltInProviderInfo}
   */
  public static <U extends BuiltInProviderInfo<U>> BuiltInProvider<U> of(
      Class<? extends U> infoClass) {
    // TODO: We'll want to probably eventually do annotation processors to make these compile time
    // errors.
    Class<U> infoApiClass = BuiltInProviderClassUtilities.findDeclaringClass(infoClass);
    if (infoApiClass.equals(infoClass)) {
      throw new IllegalArgumentException(
          "The given class should be the Immutable implementation class of the BuildInProvider "
              + "class, not the declaring API class that defined the @ImmutableInfo annotation.");
    }

    ImmutableInfo info = infoApiClass.getAnnotation(ImmutableInfo.class);
    ImmutableMap<String, Method> methodMap = MethodLookup.getMethods(infoApiClass);
    ImmutableList<String> argNames = ImmutableList.copyOf(info.args());
    ImmutableList<String> defaultSkylarkValues = ImmutableList.copyOf(info.defaultSkylarkValues());
    ImmutableSet<String> noneableParams = ImmutableSet.copyOf(info.noneable());

    List<Class<?>> types =
        Lists.transform(
            argNames,
            name ->
                Preconditions.checkNotNull(
                        methodMap.get(name),
                        "%s should have a public getter method %s",
                        infoApiClass,
                        name)
                    .getReturnType());

    @Nullable Method skylarkFactory = findSkylarkFactory(infoApiClass, argNames);

    if (skylarkFactory != null) {
      return new BuiltInProvider<>(
          infoApiClass, skylarkFactory, argNames, defaultSkylarkValues, noneableParams);
    } else {
      return fromConstructor(
          infoClass, infoApiClass, types, argNames, defaultSkylarkValues, noneableParams);
    }
  }

  private static <U extends BuiltInProviderInfo<U>> BuiltInProvider<U> fromConstructor(
      Class<? extends U> infoClass,
      Class<U> infoApiClass,
      List<Class<?>> structTypes,
      ImmutableList<String> argNames,
      ImmutableList<String> defaultSkylarkValues,
      ImmutableSet<String> noneableParams) {

    try {
      return new BuiltInProvider<>(
          infoApiClass,
          findConstructor(infoClass, structTypes),
          argNames,
          defaultSkylarkValues,
          noneableParams);
    } catch (NoSuchMethodException e) {
      throw new IllegalArgumentException(
          String.format(
              "Infos must have a public constructor that initializes all struct values but %s doesn't. Expected constructor parameters %s",
              infoClass, structTypes));
    }
  }

  @Nullable
  private static <U extends BuiltInProviderInfo<U>> Method findSkylarkFactory(
      Class<U> infoApiClass, ImmutableList<String> argNames) {
    for (Method method : infoApiClass.getMethods()) {
      if (method.getName().equals(SKYLARK_CONSTRUCTOR_METHOD_NAME)) {

        if ((method.getModifiers() & Modifier.STATIC) == 0) {
          throw new IllegalArgumentException(
              String.format(
                  "Method %s on %s must be a public static method.",
                  SKYLARK_CONSTRUCTOR_METHOD_NAME, infoApiClass.getSimpleName()));
        }
        if (!method.getReturnType().equals(infoApiClass)) {
          throw new IllegalArgumentException(
              String.format(
                  "Method %s on %s must return %s.",
                  SKYLARK_CONSTRUCTOR_METHOD_NAME,
                  infoApiClass.getSimpleName(),
                  infoApiClass.getSimpleName()));
        }
        if (method.getParameterCount() != argNames.size()) {
          // Skylark constructors may take a single extra argument of type `Location`, and it must
          // be the last argument.
          if (method.getParameterCount() != argNames.size() + 1
              || method.getParameterTypes()[method.getParameterTypes().length - 1]
                  != Location.class) {
            throw new IllegalArgumentException(
                String.format(
                    "Method %s on %s must take %s arguments, with an optional additional "
                        + "Location parameter as the last parameter",
                    SKYLARK_CONSTRUCTOR_METHOD_NAME,
                    infoApiClass.getSimpleName(),
                    argNames.size()));
          }
        }
        return method;
      }
    }
    return null;
  }

  @SuppressWarnings("unchecked")
  private static <U extends BuiltInProviderInfo<U>> Constructor<U> findConstructor(
      Class<? extends U> infoClass, List<Class<?>> values) throws NoSuchMethodException {
    try {
      return (Constructor<U>) infoClass.getConstructor(values.toArray(new Class[] {}));
    } catch (NoSuchMethodException e) {
      // no direct matching constructor. Now we check if there is a compatible constructor since
      // Immutables can generate constructors that take the Iterable type instead of the specific
      // Set/List types

      Constructor<?> found = null;
      Constructor<?>[] constructors = infoClass.getConstructors();
      outer:
      for (int i = 0; i < constructors.length; i++) {
        Parameter[] parameters = constructors[i].getParameters();
        for (int j = 0; j < parameters.length; j++) {
          if (!parameters[j].getType().isAssignableFrom(values.get(j))) {
            // not the right constructor. Go to the next constructor in outer loop
            continue outer;
          }
        }
        if (found != null) {
          throw new IllegalArgumentException(
              String.format(
                  "Multiple constructors on class %s matches signature with type of %s",
                  infoClass, values));
        }

        found = constructors[i];
      }
      if (found == null) {
        throw new NoSuchMethodException();
      }
      return (Constructor<U>) found;
    }
  }

  /**
   * Constructs the info.
   *
   * @param args the args to the {@link BuiltInProviderInfo} being constructed
   * @return the info itself
   */
  @SuppressWarnings("unchecked")
  public final T createInfo(Object... args)
      throws IllegalAccessException, InvocationTargetException, InstantiationException {
    return infoFactory.isLeft()
        ? infoFactory.getLeft().newInstance(args)
        : (T) Objects.requireNonNull(infoFactory.getRight()).invoke(args);
  }

  @Override
  public Key<T> getKey() {
    return key;
  }

  /**
   * The key for a {@link BuiltInProvider} which is unique per provider that generates the same info
   *
   * @param <U> the type of the {@link BuiltInProviderInfo}
   */
  @BuckStylePrehashedValue
  abstract static class BuiltInKey<U> implements Provider.Key<U> {
    abstract Class<?> getInfoClass();

    @Override
    public String toString() {
      return getInfoClass().getSimpleName();
    }
  }
}
